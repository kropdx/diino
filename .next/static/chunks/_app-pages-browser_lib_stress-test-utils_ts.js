"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["_app-pages-browser_lib_stress-test-utils_ts"],{

/***/ "(app-pages-browser)/./lib/stress-test-utils.ts":
/*!**********************************!*\
  !*** ./lib/stress-test-utils.ts ***!
  \**********************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ChatStressTester: () => (/* binding */ ChatStressTester)\n/* harmony export */ });\n/* harmony import */ var _lib_supabase_client__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/lib/supabase/client */ \"(app-pages-browser)/./lib/supabase/client.ts\");\n\nclass ChatStressTester {\n    async runBurstTest() {\n        let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n        const { messageCount = 100, concurrency = 10, delayBetweenBatches = 100, roomId = '00000000-0000-0000-0000-000000000001' } = options;\n        console.log(\"\\uD83D\\uDE80 Starting burst test: \".concat(messageCount, \" messages, \").concat(concurrency, \" concurrent\"));\n        const startTime = Date.now();\n        this.results = {\n            success: 0,\n            failed: 0,\n            times: []\n        };\n        // Get current user\n        const { data: { user } } = await _lib_supabase_client__WEBPACK_IMPORTED_MODULE_0__.supabase.auth.getUser();\n        if (!user) {\n            console.error('❌ Not authenticated');\n            return;\n        }\n        // Process messages in batches\n        for(let i = 0; i < messageCount; i += concurrency){\n            const batch = [];\n            for(let j = 0; j < concurrency && i + j < messageCount; j++){\n                const index = i + j;\n                batch.push(this.sendMessage(user.id, roomId, index));\n            }\n            await Promise.all(batch);\n            if (i + concurrency < messageCount) {\n                await new Promise((resolve)=>setTimeout(resolve, delayBetweenBatches));\n            }\n            // Progress update\n            console.log(\"\\uD83D\\uDCCA Progress: \".concat(Math.min(i + concurrency, messageCount), \"/\").concat(messageCount, \" messages sent\"));\n        }\n        const totalTime = (Date.now() - startTime) / 1000;\n        this.printResults(totalTime);\n    }\n    async runSpikeTest() {\n        let spikeSize = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 50;\n        console.log(\"⚡ Sending \".concat(spikeSize, \" messages simultaneously...\"));\n        const { data: { user } } = await _lib_supabase_client__WEBPACK_IMPORTED_MODULE_0__.supabase.auth.getUser();\n        if (!user) {\n            console.error('❌ Not authenticated');\n            return;\n        }\n        this.results = {\n            success: 0,\n            failed: 0,\n            times: []\n        };\n        const startTime = Date.now();\n        const promises = Array(spikeSize).fill(0).map((_, i)=>this.sendMessage(user.id, '00000000-0000-0000-0000-000000000001', i));\n        await Promise.all(promises);\n        const totalTime = (Date.now() - startTime) / 1000;\n        this.printResults(totalTime);\n    }\n    async measureRealtimeLatency() {\n        let iterations = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 10;\n        console.log(\"\\uD83D\\uDCE1 Measuring realtime latency (\".concat(iterations, \" samples)...\"));\n        const { data: { user } } = await _lib_supabase_client__WEBPACK_IMPORTED_MODULE_0__.supabase.auth.getUser();\n        if (!user) {\n            console.error('❌ Not authenticated');\n            return;\n        }\n        const latencies = [];\n        const roomId = '00000000-0000-0000-0000-000000000001';\n        // Subscribe to realtime\n        const channel = _lib_supabase_client__WEBPACK_IMPORTED_MODULE_0__.supabase.channel(\"latency-test-\".concat(Date.now()));\n        const receivedMessages = new Map();\n        channel.on('postgres_changes', {\n            event: 'INSERT',\n            schema: 'public',\n            table: 'chat_messages',\n            filter: \"room_id=eq.\".concat(roomId)\n        }, (payload)=>{\n            const sentTime = receivedMessages.get(payload.new.client_id);\n            if (sentTime) {\n                const latency = Date.now() - sentTime;\n                latencies.push(latency);\n                console.log(\"✓ Message \".concat(payload.new.client_id.slice(-8), \" latency: \").concat(latency, \"ms\"));\n            }\n        }).subscribe();\n        // Wait for subscription\n        await new Promise((resolve)=>setTimeout(resolve, 1000));\n        // Send test messages\n        for(let i = 0; i < iterations; i++){\n            const clientId = crypto.randomUUID();\n            const sentTime = Date.now();\n            receivedMessages.set(clientId, sentTime);\n            await _lib_supabase_client__WEBPACK_IMPORTED_MODULE_0__.supabase.functions.invoke('send-message', {\n                body: {\n                    room_id: roomId,\n                    content: \"Latency test \".concat(i),\n                    client_id: clientId\n                }\n            });\n            await new Promise((resolve)=>setTimeout(resolve, 200));\n        }\n        // Wait for all messages\n        await new Promise((resolve)=>setTimeout(resolve, 2000));\n        _lib_supabase_client__WEBPACK_IMPORTED_MODULE_0__.supabase.removeChannel(channel);\n        if (latencies.length > 0) {\n            const avg = latencies.reduce((a, b)=>a + b, 0) / latencies.length;\n            const min = Math.min(...latencies);\n            const max = Math.max(...latencies);\n            console.log(\"\\n\\uD83D\\uDCCA Realtime Latency Results:\\n   Average: \".concat(avg.toFixed(2), \"ms\\n   Min: \").concat(min, \"ms\\n   Max: \").concat(max, \"ms\\n   Samples: \").concat(latencies.length, \"/\").concat(iterations, \"\\n      \"));\n        } else {\n            console.log('❌ No realtime messages received');\n        }\n    }\n    async sendMessage(userId, roomId, index) {\n        const start = performance.now();\n        try {\n            const { error } = await _lib_supabase_client__WEBPACK_IMPORTED_MODULE_0__.supabase.functions.invoke('send-message', {\n                body: {\n                    room_id: roomId,\n                    content: \"Stress test message \".concat(index, \" at \").concat(new Date().toISOString()),\n                    client_id: crypto.randomUUID()\n                }\n            });\n            const time = performance.now() - start;\n            this.results.times.push(time);\n            if (error) {\n                this.results.failed++;\n                console.error(\"❌ Message \".concat(index, \" failed:\"), error);\n            } else {\n                this.results.success++;\n            }\n        } catch (e) {\n            this.results.failed++;\n            console.error(\"❌ Message \".concat(index, \" error:\"), e);\n        }\n    }\n    printResults(totalTime) {\n        const avgTime = this.results.times.length > 0 ? this.results.times.reduce((a, b)=>a + b, 0) / this.results.times.length : 0;\n        const minTime = this.results.times.length > 0 ? Math.min(...this.results.times) : 0;\n        const maxTime = this.results.times.length > 0 ? Math.max(...this.results.times) : 0;\n        console.log(\"\\n\\uD83C\\uDFC1 Stress Test Complete!\\n━━━━━━━━━━━━━━━━━━━━━━\\n✅ Successful: \".concat(this.results.success, \"\\n❌ Failed: \").concat(this.results.failed, \"\\n⏱️  Total Time: \").concat(totalTime.toFixed(2), \"s\\n\\uD83D\\uDCCA Messages/sec: \").concat((this.results.success / totalTime).toFixed(2), \"\\n\\nResponse Times:\\n  Average: \").concat(avgTime.toFixed(2), \"ms\\n  Min: \").concat(minTime.toFixed(2), \"ms\\n  Max: \").concat(maxTime.toFixed(2), \"ms\\n━━━━━━━━━━━━━━━━━━━━━━\\n    \"));\n    }\n    constructor(){\n        this.results = {\n            success: 0,\n            failed: 0,\n            times: []\n        };\n    }\n}\n// Export for browser console usage\nif (true) {\n    window.ChatStressTester = ChatStressTester;\n    console.log(\"\\n\\uD83E\\uDDEA Chat Stress Testing Tools Loaded!\\n\\nQuick commands:\\n  const tester = new ChatStressTester();\\n  \\n  // Send 100 messages with 10 concurrent\\n  await tester.runBurstTest({ messageCount: 100, concurrency: 10 });\\n  \\n  // Send 50 messages all at once\\n  await tester.runSpikeTest(50);\\n  \\n  // Measure realtime latency\\n  await tester.measureRealtimeLatency(10);\\n  \");\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2xpYi9zdHJlc3MtdGVzdC11dGlscy50cyIsIm1hcHBpbmdzIjoiOzs7OztBQUFpRDtBQVMxQyxNQUFNQztJQU9YLE1BQU1DLGVBQThDO1lBQWpDQyxVQUFBQSxpRUFBNkIsQ0FBQztRQUMvQyxNQUFNLEVBQ0pDLGVBQWUsR0FBRyxFQUNsQkMsY0FBYyxFQUFFLEVBQ2hCQyxzQkFBc0IsR0FBRyxFQUN6QkMsU0FBUyxzQ0FBc0MsRUFDaEQsR0FBR0o7UUFFSkssUUFBUUMsR0FBRyxDQUFDLHFDQUFxREosT0FBMUJELGNBQWEsZUFBeUIsT0FBWkMsYUFBWTtRQUU3RSxNQUFNSyxZQUFZQyxLQUFLQyxHQUFHO1FBQzFCLElBQUksQ0FBQ0MsT0FBTyxHQUFHO1lBQUVDLFNBQVM7WUFBR0MsUUFBUTtZQUFHQyxPQUFPLEVBQUU7UUFBQztRQUVsRCxtQkFBbUI7UUFDbkIsTUFBTSxFQUFFQyxNQUFNLEVBQUVDLElBQUksRUFBRSxFQUFFLEdBQUcsTUFBTWxCLDBEQUFRQSxDQUFDbUIsSUFBSSxDQUFDQyxPQUFPO1FBQ3RELElBQUksQ0FBQ0YsTUFBTTtZQUNUVixRQUFRYSxLQUFLLENBQUM7WUFDZDtRQUNGO1FBRUEsOEJBQThCO1FBQzlCLElBQUssSUFBSUMsSUFBSSxHQUFHQSxJQUFJbEIsY0FBY2tCLEtBQUtqQixZQUFhO1lBQ2xELE1BQU1rQixRQUFRLEVBQUU7WUFFaEIsSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUluQixlQUFlaUIsSUFBSUUsSUFBSXBCLGNBQWNvQixJQUFLO2dCQUM1RCxNQUFNQyxRQUFRSCxJQUFJRTtnQkFDbEJELE1BQU1HLElBQUksQ0FBQyxJQUFJLENBQUNDLFdBQVcsQ0FBQ1QsS0FBS1UsRUFBRSxFQUFFckIsUUFBUWtCO1lBQy9DO1lBRUEsTUFBTUksUUFBUUMsR0FBRyxDQUFDUDtZQUVsQixJQUFJRCxJQUFJakIsY0FBY0QsY0FBYztnQkFDbEMsTUFBTSxJQUFJeUIsUUFBUUUsQ0FBQUEsVUFB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QU0sRUFBQyxzQkFFYixPQUREb0IsVUFBVTRDLE9BQU8sQ0FBQyxJQUFHLGtDQUkxQk8sT0FITSxDQUFDLElBQUksQ0FBQ3pFLE9BQU8sQ0FBQ0MsT0FBTyxHQUFHcUIsU0FBUSxFQUFHNEMsT0FBTyxDQUFDLElBQUcsb0NBSXhEUSxPQURJRCxRQUFRUCxPQUFPLENBQUMsSUFBRyxlQUV2QlMsT0FEQUQsUUFBUVIsT0FBTyxDQUFDLElBQUcsZUFDQSxPQUFuQlMsUUFBUVQsT0FBTyxDQUFDLElBQUc7SUFHMUI7O2FBL0xRbEUsVUFBZ0U7WUFDdEVDLFNBQVM7WUFDVEMsUUFBUTtZQUNSQyxPQUFPLEVBQUU7UUFDWDs7QUE0TEY7QUFFQSxtQ0FBbUM7QUFDbkMsSUFBSSxJQUE2QixFQUFFO0lBQ2hDeUUsT0FBb0V4RixnQkFBZ0IsR0FBR0E7SUFFeEZPLFFBQVFDLEdBQUcsQ0FBRTtBQWVmIiwic291cmNlcyI6WyIvVXNlcnMva2V2aW5yb3NlL0xpYnJhcnkvQ2xvdWRTdG9yYWdlL0Ryb3Bib3gvdmliZS9kaWluby9saWIvc3RyZXNzLXRlc3QtdXRpbHMudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgc3VwYWJhc2UgfSBmcm9tICdAL2xpYi9zdXBhYmFzZS9jbGllbnQnO1xuXG5pbnRlcmZhY2UgU3RyZXNzVGVzdE9wdGlvbnMge1xuICBtZXNzYWdlQ291bnQ/OiBudW1iZXI7XG4gIGNvbmN1cnJlbmN5PzogbnVtYmVyO1xuICBkZWxheUJldHdlZW5CYXRjaGVzPzogbnVtYmVyO1xuICByb29tSWQ/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBjbGFzcyBDaGF0U3RyZXNzVGVzdGVyIHtcbiAgcHJpdmF0ZSByZXN1bHRzOiB7IHN1Y2Nlc3M6IG51bWJlcjsgZmFpbGVkOiBudW1iZXI7IHRpbWVzOiBudW1iZXJbXSB9ID0ge1xuICAgIHN1Y2Nlc3M6IDAsXG4gICAgZmFpbGVkOiAwLFxuICAgIHRpbWVzOiBbXSxcbiAgfTtcblxuICBhc3luYyBydW5CdXJzdFRlc3Qob3B0aW9uczogU3RyZXNzVGVzdE9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHtcbiAgICAgIG1lc3NhZ2VDb3VudCA9IDEwMCxcbiAgICAgIGNvbmN1cnJlbmN5ID0gMTAsXG4gICAgICBkZWxheUJldHdlZW5CYXRjaGVzID0gMTAwLFxuICAgICAgcm9vbUlkID0gJzAwMDAwMDAwLTAwMDAtMDAwMC0wMDAwLTAwMDAwMDAwMDAwMScsXG4gICAgfSA9IG9wdGlvbnM7XG5cbiAgICBjb25zb2xlLmxvZyhg8J+agCBTdGFydGluZyBidXJzdCB0ZXN0OiAke21lc3NhZ2VDb3VudH0gbWVzc2FnZXMsICR7Y29uY3VycmVuY3l9IGNvbmN1cnJlbnRgKTtcbiAgICBcbiAgICBjb25zdCBzdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuICAgIHRoaXMucmVzdWx0cyA9IHsgc3VjY2VzczogMCwgZmFpbGVkOiAwLCB0aW1lczogW10gfTtcblxuICAgIC8vIEdldCBjdXJyZW50IHVzZXJcbiAgICBjb25zdCB7IGRhdGE6IHsgdXNlciB9IH0gPSBhd2FpdCBzdXBhYmFzZS5hdXRoLmdldFVzZXIoKTtcbiAgICBpZiAoIXVzZXIpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBOb3QgYXV0aGVudGljYXRlZCcpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIFByb2Nlc3MgbWVzc2FnZXMgaW4gYmF0Y2hlc1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWVzc2FnZUNvdW50OyBpICs9IGNvbmN1cnJlbmN5KSB7XG4gICAgICBjb25zdCBiYXRjaCA9IFtdO1xuICAgICAgXG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGNvbmN1cnJlbmN5ICYmIGkgKyBqIDwgbWVzc2FnZUNvdW50OyBqKyspIHtcbiAgICAgICAgY29uc3QgaW5kZXggPSBpICsgajtcbiAgICAgICAgYmF0Y2gucHVzaCh0aGlzLnNlbmRNZXNzYWdlKHVzZXIuaWQsIHJvb21JZCwgaW5kZXgpKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoYmF0Y2gpO1xuICAgICAgXG4gICAgICBpZiAoaSArIGNvbmN1cnJlbmN5IDwgbWVzc2FnZUNvdW50KSB7XG4gICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCBkZWxheUJldHdlZW5CYXRjaGVzKSk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIFByb2dyZXNzIHVwZGF0ZVxuICAgICAgY29uc29sZS5sb2coYPCfk4ogUHJvZ3Jlc3M6ICR7TWF0aC5taW4oaSArIGNvbmN1cnJlbmN5LCBtZXNzYWdlQ291bnQpfS8ke21lc3NhZ2VDb3VudH0gbWVzc2FnZXMgc2VudGApO1xuICAgIH1cblxuICAgIGNvbnN0IHRvdGFsVGltZSA9IChEYXRlLm5vdygpIC0gc3RhcnRUaW1lKSAvIDEwMDA7XG4gICAgdGhpcy5wcmludFJlc3VsdHModG90YWxUaW1lKTtcbiAgfVxuXG4gIGFzeW5jIHJ1blNwaWtlVGVzdChzcGlrZVNpemU6IG51bWJlciA9IDUwKSB7XG4gICAgY29uc29sZS5sb2coYOKaoSBTZW5kaW5nICR7c3Bpa2VTaXplfSBtZXNzYWdlcyBzaW11bHRhbmVvdXNseS4uLmApO1xuICAgIFxuICAgIGNvbnN0IHsgZGF0YTogeyB1c2VyIH0gfSA9IGF3YWl0IHN1cGFiYXNlLmF1dGguZ2V0VXNlcigpO1xuICAgIGlmICghdXNlcikge1xuICAgICAgY29uc29sZS5lcnJvcign4p2MIE5vdCBhdXRoZW50aWNhdGVkJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5yZXN1bHRzID0geyBzdWNjZXNzOiAwLCBmYWlsZWQ6IDAsIHRpbWVzOiBbXSB9O1xuICAgIGNvbnN0IHN0YXJ0VGltZSA9IERhdGUubm93KCk7XG4gICAgXG4gICAgY29uc3QgcHJvbWlzZXMgPSBBcnJheShzcGlrZVNpemUpLmZpbGwoMCkubWFwKChfLCBpKSA9PiBcbiAgICAgIHRoaXMuc2VuZE1lc3NhZ2UodXNlci5pZCwgJzAwMDAwMDAwLTAwMDAtMDAwMC0wMDAwLTAwMDAwMDAwMDAwMScsIGkpXG4gICAgKTtcbiAgICBcbiAgICBhd2FpdCBQcm9taXNlLmFsbChwcm9taXNlcyk7XG4gICAgXG4gICAgY29uc3QgdG90YWxUaW1lID0gKERhdGUubm93KCkgLSBzdGFydFRpbWUpIC8gMTAwMDtcbiAgICB0aGlzLnByaW50UmVzdWx0cyh0b3RhbFRpbWUpO1xuICB9XG5cbiAgYXN5bmMgbWVhc3VyZVJlYWx0aW1lTGF0ZW5jeShpdGVyYXRpb25zOiBudW1iZXIgPSAxMCkge1xuICAgIGNvbnNvbGUubG9nKGDwn5OhIE1lYXN1cmluZyByZWFsdGltZSBsYXRlbmN5ICgke2l0ZXJhdGlvbnN9IHNhbXBsZXMpLi4uYCk7XG4gICAgXG4gICAgY29uc3QgeyBkYXRhOiB7IHVzZXIgfSB9ID0gYXdhaXQgc3VwYWJhc2UuYXV0aC5nZXRVc2VyKCk7XG4gICAgaWYgKCF1c2VyKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCfinYwgTm90IGF1dGhlbnRpY2F0ZWQnKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBsYXRlbmNpZXM6IG51bWJlcltdID0gW107XG4gICAgY29uc3Qgcm9vbUlkID0gJzAwMDAwMDAwLTAwMDAtMDAwMC0wMDAwLTAwMDAwMDAwMDAwMSc7XG4gICAgXG4gICAgLy8gU3Vic2NyaWJlIHRvIHJlYWx0aW1lXG4gICAgY29uc3QgY2hhbm5lbCA9IHN1cGFiYXNlLmNoYW5uZWwoYGxhdGVuY3ktdGVzdC0ke0RhdGUubm93KCl9YCk7XG4gICAgY29uc3QgcmVjZWl2ZWRNZXNzYWdlcyA9IG5ldyBNYXA8c3RyaW5nLCBudW1iZXI+KCk7XG4gICAgXG4gICAgY2hhbm5lbFxuICAgICAgLm9uKCdwb3N0Z3Jlc19jaGFuZ2VzJywgXG4gICAgICAgIHsgZXZlbnQ6ICdJTlNFUlQnLCBzY2hlbWE6ICdwdWJsaWMnLCB0YWJsZTogJ2NoYXRfbWVzc2FnZXMnLCBmaWx0ZXI6IGByb29tX2lkPWVxLiR7cm9vbUlkfWAgfSxcbiAgICAgICAgKHBheWxvYWQ6IHsgbmV3OiB7IGNsaWVudF9pZDogc3RyaW5nIH0gfSkgPT4ge1xuICAgICAgICAgIGNvbnN0IHNlbnRUaW1lID0gcmVjZWl2ZWRNZXNzYWdlcy5nZXQocGF5bG9hZC5uZXcuY2xpZW50X2lkKTtcbiAgICAgICAgICBpZiAoc2VudFRpbWUpIHtcbiAgICAgICAgICAgIGNvbnN0IGxhdGVuY3kgPSBEYXRlLm5vdygpIC0gc2VudFRpbWU7XG4gICAgICAgICAgICBsYXRlbmNpZXMucHVzaChsYXRlbmN5KTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGDinJMgTWVzc2FnZSAke3BheWxvYWQubmV3LmNsaWVudF9pZC5zbGljZSgtOCl9IGxhdGVuY3k6ICR7bGF0ZW5jeX1tc2ApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgKVxuICAgICAgLnN1YnNjcmliZSgpO1xuXG4gICAgLy8gV2FpdCBmb3Igc3Vic2NyaXB0aW9uXG4gICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDEwMDApKTtcblxuICAgIC8vIFNlbmQgdGVzdCBtZXNzYWdlc1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaXRlcmF0aW9uczsgaSsrKSB7XG4gICAgICBjb25zdCBjbGllbnRJZCA9IGNyeXB0by5yYW5kb21VVUlEKCk7XG4gICAgICBjb25zdCBzZW50VGltZSA9IERhdGUubm93KCk7XG4gICAgICByZWNlaXZlZE1lc3NhZ2VzLnNldChjbGllbnRJZCwgc2VudFRpbWUpO1xuICAgICAgXG4gICAgICBhd2FpdCBzdXBhYmFzZS5mdW5jdGlvbnMuaW52b2tlKCdzZW5kLW1lc3NhZ2UnLCB7XG4gICAgICAgIGJvZHk6IHtcbiAgICAgICAgICByb29tX2lkOiByb29tSWQsXG4gICAgICAgICAgY29udGVudDogYExhdGVuY3kgdGVzdCAke2l9YCxcbiAgICAgICAgICBjbGllbnRfaWQ6IGNsaWVudElkLFxuICAgICAgICB9LFxuICAgICAgfSk7XG4gICAgICBcbiAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCAyMDApKTtcbiAgICB9XG5cbiAgICAvLyBXYWl0IGZvciBhbGwgbWVzc2FnZXNcbiAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMjAwMCkpO1xuICAgIHN1cGFiYXNlLnJlbW92ZUNoYW5uZWwoY2hhbm5lbCk7XG5cbiAgICBpZiAobGF0ZW5jaWVzLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IGF2ZyA9IGxhdGVuY2llcy5yZWR1Y2UoKGEsIGIpID0+IGEgKyBiLCAwKSAvIGxhdGVuY2llcy5sZW5ndGg7XG4gICAgICBjb25zdCBtaW4gPSBNYXRoLm1pbiguLi5sYXRlbmNpZXMpO1xuICAgICAgY29uc3QgbWF4ID0gTWF0aC5tYXgoLi4ubGF0ZW5jaWVzKTtcbiAgICAgIFxuICAgICAgY29uc29sZS5sb2coYFxu8J+TiiBSZWFsdGltZSBMYXRlbmN5IFJlc3VsdHM6XG4gICBBdmVyYWdlOiAke2F2Zy50b0ZpeGVkKDIpfW1zXG4gICBNaW46ICR7bWlufW1zXG4gICBNYXg6ICR7bWF4fW1zXG4gICBTYW1wbGVzOiAke2xhdGVuY2llcy5sZW5ndGh9LyR7aXRlcmF0aW9uc31cbiAgICAgIGApO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLmxvZygn4p2MIE5vIHJlYWx0aW1lIG1lc3NhZ2VzIHJlY2VpdmVkJyk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBzZW5kTWVzc2FnZSh1c2VySWQ6IHN0cmluZywgcm9vbUlkOiBzdHJpbmcsIGluZGV4OiBudW1iZXIpIHtcbiAgICBjb25zdCBzdGFydCA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgIFxuICAgIHRyeSB7XG4gICAgICBjb25zdCB7IGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZS5mdW5jdGlvbnMuaW52b2tlKCdzZW5kLW1lc3NhZ2UnLCB7XG4gICAgICAgIGJvZHk6IHtcbiAgICAgICAgICByb29tX2lkOiByb29tSWQsXG4gICAgICAgICAgY29udGVudDogYFN0cmVzcyB0ZXN0IG1lc3NhZ2UgJHtpbmRleH0gYXQgJHtuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCl9YCxcbiAgICAgICAgICBjbGllbnRfaWQ6IGNyeXB0by5yYW5kb21VVUlEKCksXG4gICAgICAgIH0sXG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgY29uc3QgdGltZSA9IHBlcmZvcm1hbmNlLm5vdygpIC0gc3RhcnQ7XG4gICAgICB0aGlzLnJlc3VsdHMudGltZXMucHVzaCh0aW1lKTtcbiAgICAgIFxuICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgIHRoaXMucmVzdWx0cy5mYWlsZWQrKztcbiAgICAgICAgY29uc29sZS5lcnJvcihg4p2MIE1lc3NhZ2UgJHtpbmRleH0gZmFpbGVkOmAsIGVycm9yKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucmVzdWx0cy5zdWNjZXNzKys7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgdGhpcy5yZXN1bHRzLmZhaWxlZCsrO1xuICAgICAgY29uc29sZS5lcnJvcihg4p2MIE1lc3NhZ2UgJHtpbmRleH0gZXJyb3I6YCwgZSk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBwcmludFJlc3VsdHModG90YWxUaW1lOiBudW1iZXIpIHtcbiAgICBjb25zdCBhdmdUaW1lID0gdGhpcy5yZXN1bHRzLnRpbWVzLmxlbmd0aCA+IDAgXG4gICAgICA/IHRoaXMucmVzdWx0cy50aW1lcy5yZWR1Y2UoKGEsIGIpID0+IGEgKyBiLCAwKSAvIHRoaXMucmVzdWx0cy50aW1lcy5sZW5ndGggXG4gICAgICA6IDA7XG4gICAgXG4gICAgY29uc3QgbWluVGltZSA9IHRoaXMucmVzdWx0cy50aW1lcy5sZW5ndGggPiAwID8gTWF0aC5taW4oLi4udGhpcy5yZXN1bHRzLnRpbWVzKSA6IDA7XG4gICAgY29uc3QgbWF4VGltZSA9IHRoaXMucmVzdWx0cy50aW1lcy5sZW5ndGggPiAwID8gTWF0aC5tYXgoLi4udGhpcy5yZXN1bHRzLnRpbWVzKSA6IDA7XG4gICAgXG4gICAgY29uc29sZS5sb2coYFxu8J+PgSBTdHJlc3MgVGVzdCBDb21wbGV0ZSFcbuKUgeKUgeKUgeKUgeKUgeKUgeKUgeKUgeKUgeKUgeKUgeKUgeKUgeKUgeKUgeKUgeKUgeKUgeKUgeKUgeKUgeKUgVxu4pyFIFN1Y2Nlc3NmdWw6ICR7dGhpcy5yZXN1bHRzLnN1Y2Nlc3N9XG7inYwgRmFpbGVkOiAke3RoaXMucmVzdWx0cy5mYWlsZWR9XG7ij7HvuI8gIFRvdGFsIFRpbWU6ICR7dG90YWxUaW1lLnRvRml4ZWQoMil9c1xu8J+TiiBNZXNzYWdlcy9zZWM6ICR7KHRoaXMucmVzdWx0cy5zdWNjZXNzIC8gdG90YWxUaW1lKS50b0ZpeGVkKDIpfVxuXG5SZXNwb25zZSBUaW1lczpcbiAgQXZlcmFnZTogJHthdmdUaW1lLnRvRml4ZWQoMil9bXNcbiAgTWluOiAke21pblRpbWUudG9GaXhlZCgyKX1tc1xuICBNYXg6ICR7bWF4VGltZS50b0ZpeGVkKDIpfW1zXG7ilIHilIHilIHilIHilIHilIHilIHilIHilIHilIHilIHilIHilIHilIHilIHilIHilIHilIHilIHilIHilIHilIFcbiAgICBgKTtcbiAgfVxufVxuXG4vLyBFeHBvcnQgZm9yIGJyb3dzZXIgY29uc29sZSB1c2FnZVxuaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICh3aW5kb3cgYXMgdW5rbm93biBhcyB7IENoYXRTdHJlc3NUZXN0ZXI6IHR5cGVvZiBDaGF0U3RyZXNzVGVzdGVyIH0pLkNoYXRTdHJlc3NUZXN0ZXIgPSBDaGF0U3RyZXNzVGVzdGVyO1xuICBcbiAgY29uc29sZS5sb2coYFxu8J+nqiBDaGF0IFN0cmVzcyBUZXN0aW5nIFRvb2xzIExvYWRlZCFcblxuUXVpY2sgY29tbWFuZHM6XG4gIGNvbnN0IHRlc3RlciA9IG5ldyBDaGF0U3RyZXNzVGVzdGVyKCk7XG4gIFxuICAvLyBTZW5kIDEwMCBtZXNzYWdlcyB3aXRoIDEwIGNvbmN1cnJlbnRcbiAgYXdhaXQgdGVzdGVyLnJ1bkJ1cnN0VGVzdCh7IG1lc3NhZ2VDb3VudDogMTAwLCBjb25jdXJyZW5jeTogMTAgfSk7XG4gIFxuICAvLyBTZW5kIDUwIG1lc3NhZ2VzIGFsbCBhdCBvbmNlXG4gIGF3YWl0IHRlc3Rlci5ydW5TcGlrZVRlc3QoNTApO1xuICBcbiAgLy8gTWVhc3VyZSByZWFsdGltZSBsYXRlbmN5XG4gIGF3YWl0IHRlc3Rlci5tZWFzdXJlUmVhbHRpbWVMYXRlbmN5KDEwKTtcbiAgYCk7XG59ICJdLCJuYW1lcyI6WyJzdXBhYmFzZSIsIkNoYXRTdHJlc3NUZXN0ZXIiLCJydW5CdXJzdFRlc3QiLCJvcHRpb25zIiwibWVzc2FnZUNvdW50IiwiY29uY3VycmVuY3kiLCJkZWxheUJldHdlZW5CYXRjaGVzIiwicm9vbUlkIiwiY29uc29sZSIsImxvZyIsInN0YXJ0VGltZSIsIkRhdGUiLCJub3ciLCJyZXN1bHRzIiwic3VjY2VzcyIsImZhaWxlZCIsInRpbWVzIiwiZGF0YSIsInVzZXIiLCJhdXRoIiwiZ2V0VXNlciIsImVycm9yIiwiaSIsImJhdGNoIiwiaiIsImluZGV4IiwicHVzaCIsInNlbmRNZXNzYWdlIiwiaWQiLCJQcm9taXNlIiwiYWxsIiwicmVzb2x2ZSIsInNldFRpbWVvdXQiLCJNYXRoIiwibWluIiwidG90YWxUaW1lIiwicHJpbnRSZXN1bHRzIiwicnVuU3Bpa2VUZXN0Iiwic3Bpa2VTaXplIiwicHJvbWlzZXMiLCJBcnJheSIsImZpbGwiLCJtYXAiLCJfIiwibWVhc3VyZVJlYWx0aW1lTGF0ZW5jeSIsIml0ZXJhdGlvbnMiLCJsYXRlbmNpZXMiLCJjaGFubmVsIiwicmVjZWl2ZWRNZXNzYWdlcyIsIk1hcCIsIm9uIiwiZXZlbnQiLCJzY2hlbWEiLCJ0YWJsZSIsImZpbHRlciIsInBheWxvYWQiLCJzZW50VGltZSIsImdldCIsIm5ldyIsImNsaWVudF9pZCIsImxhdGVuY3kiLCJzbGljZSIsInN1YnNjcmliZSIsImNsaWVudElkIiwiY3J5cHRvIiwicmFuZG9tVVVJRCIsInNldCIsImZ1bmN0aW9ucyIsImludm9rZSIsImJvZHkiLCJyb29tX2lkIiwiY29udGVudCIsInJlbW92ZUNoYW5uZWwiLCJsZW5ndGgiLCJhdmciLCJyZWR1Y2UiLCJhIiwiYiIsIm1heCIsInRvRml4ZWQiLCJ1c2VySWQiLCJzdGFydCIsInBlcmZvcm1hbmNlIiwidG9JU09TdHJpbmciLCJ0aW1lIiwiZSIsImF2Z1RpbWUiLCJtaW5UaW1lIiwibWF4VGltZSIsIndpbmRvdyJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/stress-test-utils.ts\n"));

/***/ })

}]);